"""PDF generation from markdown answers.

This module converts markdown answers to styled PDF documents using WeasyPrint.
"""

import os
from datetime import datetime
from pathlib import Path
from typing import Optional

from markdown_it import MarkdownIt

try:
    from weasyprint import HTML, CSS
    WEASYPRINT_AVAILABLE = True
except ImportError:
    WEASYPRINT_AVAILABLE = False
    print("WeasyPrint not available - PDF generation will be disabled")

from backend.app.core.config import get_config
from backend.app.core.singletons import LoggerSingleton

_cfg = get_config()
_logger = LoggerSingleton().get()

# Initialize markdown parser with common features
_md = MarkdownIt("commonmark", {
    "html": True,         # Allow HTML tags
    "linkify": True,      # Auto-convert URLs to links
    "typographer": True   # Smart quotes, dashes, etc.
})


def _ensure_saved_dir() -> Path:
    """Ensure the saved directory exists."""
    saved_dir = _cfg.SAVED_DIR
    saved_dir.mkdir(parents=True, exist_ok=True)
    return saved_dir


def _build_html_document(answer_md: str, query: str) -> str:
    """Build a complete HTML document from markdown content."""
    # Convert markdown to HTML
    html_body = _md.render(answer_md)
    
    # Create timestamp for the document
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Build complete HTML document with metadata
    html_doc = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SocioGraph Answer - {query[:50]}...</title>
    <meta name="generator" content="SocioGraph">
    <meta name="created" content="{timestamp}">
</head>
<body>
    <header>
        <h1>SocioGraph Answer</h1>
        <div class="query-info">
            <strong>Query:</strong> {query}
        </div>
        <div class="timestamp">
            <strong>Generated:</strong> {timestamp}
        </div>
        <hr>
    </header>
    
    <main>
        {html_body}
    </main>
    
    <footer>
        <hr>
        <p><em>Generated by SocioGraph - AI-powered document analysis and knowledge graph</em></p>
    </footer>
</body>
</html>"""
    
    return html_doc


def save_pdf(answer_md: str, query: str, filename: Optional[str] = None) -> Path:
    """Save a markdown answer as a styled PDF.
    
    Args:
        answer_md: The markdown content to convert
        query: The original query (used for metadata)
        filename: Optional custom filename (without extension)
        
    Returns:
        Path to the saved PDF file
    """
    _logger.info(f"Starting PDF generation for query: {query[:100]}...")
    
    if not WEASYPRINT_AVAILABLE:
        # Fallback: save as HTML file instead of PDF
        _logger.warning("WeasyPrint not available - saving as HTML instead of PDF")
        return _save_as_html(answer_md, query, filename)
    
    try:
        # Ensure output directory exists
        saved_dir = _ensure_saved_dir()
        
        # Generate filename if not provided
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"answer_{timestamp}"
        
        # Ensure .pdf extension
        if not filename.endswith('.pdf'):
            filename = f"{filename}.pdf"
            
        output_path = saved_dir / filename
        
        # Build HTML document
        html_content = _build_html_document(answer_md, query)
        
        # Check if CSS theme file exists
        css_path = _cfg.PDF_THEME
        if not css_path.exists():
            _logger.warning(f"PDF theme CSS not found at {css_path}, using default styling")
            stylesheets = []
        else:
            stylesheets = [CSS(str(css_path))]
        
        # Generate PDF
        _logger.info(f"Rendering PDF to {output_path}")
        HTML(string=html_content, base_url=str(_cfg.BASE_DIR)).write_pdf(
            str(output_path), 
            stylesheets=stylesheets
        )
        
        # Verify file was created
        if output_path.exists():
            file_size = output_path.stat().st_size
            _logger.info(f"PDF successfully created: {output_path} ({file_size} bytes)")
            return output_path
        else:
            raise RuntimeError("PDF file was not created")
            
    except Exception as e:
        _logger.error(f"Error generating PDF: {e}")
        raise RuntimeError(f"Failed to generate PDF: {str(e)}")


def _save_as_html(answer_md: str, query: str, filename: Optional[str] = None) -> Path:
    """Fallback function to save as HTML when PDF generation is not available."""
    saved_dir = _ensure_saved_dir()
    
    # Generate filename if not provided
    if filename is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"answer_{timestamp}"
    
    # Use .html extension for fallback
    if filename.endswith('.pdf'):
        filename = filename[:-4] + '.html'
    elif not filename.endswith('.html'):
        filename = f"{filename}.html"
        
    output_path = saved_dir / filename
    
    # Build HTML document
    html_content = _build_html_document(answer_md, query)
    
    # Write HTML file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    _logger.info(f"HTML file created: {output_path}")
    return output_path


def get_pdf_url(pdf_path: Path) -> str:
    """Generate a URL for accessing a saved PDF.
    
    Args:
        pdf_path: Path to the PDF file
        
    Returns:
        Relative URL for accessing the PDF
    """
    # Get relative path from saved directory
    try:
        relative_path = pdf_path.relative_to(_cfg.SAVED_DIR)
        return f"/static/saved/{relative_path}"
    except ValueError:
        # If path is not relative to saved dir, use just the filename
        return f"/static/saved/{pdf_path.name}"
